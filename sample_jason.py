from __future__ import unicode_literals, print_function, division
from io import open
import unicodedata
import string
import re
import random
import time
import math
import torch
import torch.nn as nn
from torch import optim
import torch.nn.functional as F
import matplotlib.pyplot as plt
plt.switch_backend('agg')
import matplotlib.ticker as ticker
import numpy as np
from os import system
from nltk.translate.bleu_score import SmoothingFunction, sentence_bleu
import os
os.environ['CUDA_LAUNCH_BLOCKING'] = "1"



"""========================================================================================
The sample.py includes the following template functions:

1. Encoder, decoder
2. Training function
3. BLEU-4 score function
4. Gaussian score function

You have to modify them to complete the lab.
In addition, there are still other functions that you have to 
implement by yourself.

1. The reparameterization trick
2. Your own dataloader (design in your own way, not necessary Pytorch Dataloader)
3. Output your results (BLEU-4 score, conversion words, Gaussian score, generation words)
4. Plot loss/score
5. Load/save weights

There are some useful tips listed in the lab assignment.
You should check them before starting your lab.
========================================================================================"""
# GPU
device = 'cuda:0' if torch.cuda.is_available() else 'cpu'
print('GPU state:', device)
#device = torch.device("cpu")
# SOS_token = np.array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
#EOS_token = np.array([0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
SOS_token = 0
EOS_token = 1
#----------Hyper Parameters----------#
hidden_size = 128
#The number of vocabulary
vocab_size = 28
latent_size = 32
condition_embedded_size = 8
teacher_forcing_ratio = 0.6
empty_input_ratio = 0.1
KLD_weight = 0.0001
KL_annealing_period = 10e6
KL_annealing_mode = "Monotonic"
LR = 0.05


################################
#Example inputs of compute_bleu
################################
#The target word
reference = 'accessed'
#The word generated by your model
output = 'access'

#compute BLEU-4 score
def compute_bleu(output, reference):
    cc = SmoothingFunction()
    if len(reference) == 3:
        weights = (0.33,0.33,0.33)
    else:
        weights = (0.25,0.25,0.25,0.25)
    return sentence_bleu([reference], output,weights=weights,smoothing_function=cc.method1)


"""============================================================================
example input of Gaussian_score

words = [['consult', 'consults', 'consulting', 'consulted'],
['plead', 'pleads', 'pleading', 'pleaded'],
['explain', 'explains', 'explaining', 'explained'],
['amuse', 'amuses', 'amusing', 'amused'], ....]

the order should be : simple present, third person, present progressive, past
============================================================================"""

def Gaussian_score(words):
    words_list = []
    score = 0
    yourpath = './train.txt'#should be your directory of train.txt
    with open(yourpath,'r') as fp:
        for line in fp:
            word = line.split(' ')
            word[3] = word[3].strip('\n')
            words_list.extend([word])
        for t in words:
            for i in words_list:
                if t == i:
                    score += 1
    return score/len(words)

def string2one_hot(strng):
    alphabet = string.ascii_lowercase
    matrix = np.zeros([len(strng), len(alphabet)+2], dtype=int)# SOS,EOS,A,B,....Z
    for i in range(len(strng)):
        for j in range(len(alphabet)):
            if strng[i] == alphabet[j]:
                matrix[i][j+2]=1
    return matrix

def string2num(strng):
    matrix = []
    for i in strng:
        number = ord(i) - 96 + 1
        matrix.append(number)
    return np.array(matrix)

#Encoder
class EncoderRNN(nn.Module):
    def __init__(self, input_size, output_size, hidden_size, condition_size):
        super(EncoderRNN, self).__init__()
        self.hidden_size = hidden_size
        self.condition_emb = nn.Embedding(4, condition_size) # 4 means 4 tense of vocabulary
        self.embedding = nn.Embedding(input_size, hidden_size+condition_size)
        self.lstm1 = nn.LSTM(hidden_size+condition_size, hidden_size+condition_size)
        self.fc11 = nn.Linear(hidden_size+condition_size, output_size)
        self.fc12 = nn.Linear(hidden_size+condition_size, output_size)

    def encode(self, x, hidden):
        #print(x)
        x = self.embedding(x)
        x = x.view(1, 1, -1)

        lstm_output, lstm_hidden = self.lstm1(x, hidden)
        return lstm_output, lstm_hidden

    def reparameterize(self, lstm_hidden):
        lstm_hidden = F.relu(lstm_hidden)
        mu = self.fc11(lstm_hidden)
        logvar = self.fc12(lstm_hidden)
        #std = torch.exp(0.5 * logvar)
        #eps = torch.randn_like(std)
        return mu, logvar

    def forward(self, input, condition):
        condition = self.condition_emb(condition).view(1, 1, -1)
        condition = F.relu(condition)
        hidden = self.initHidden(condition)
        #print("hidden shape", hidden[0].size())

        input_size = input.size(0) #?????
        #print("input size", input_size)
        for i in range(input_size):
            _, hidden = self.encode(input[i], hidden)

        _, hidden = hidden
        mu, logvar = self.reparameterize(hidden)
        return mu, logvar

    def initHidden(self, condition):
        #print(torch.cat((torch.zeros(1, 1, self.hidden_size, device=device), condition), dim=2))
        return (torch.cat((torch.zeros(1, 1, self.hidden_size, device=device), condition), dim=2),
                torch.cat((torch.zeros(1, 1, self.hidden_size, device=device), condition), dim=2))

#Decoder
class DecoderRNN(nn.Module):
    def __init__(self, input_size, latent_size, hidden_size, output_size, condition_size):
        super(DecoderRNN, self).__init__()
        self.hidden_size = hidden_size
        self.condition_emb = nn.Embedding(4, condition_size)  # 4 means 4 tense of vocabulary
        self.embedding = nn.Embedding(input_size, hidden_size+condition_size)
        self.lstm1 = nn.LSTM(hidden_size+condition_size, hidden_size+condition_size)
        self.out = nn.Linear(hidden_size+condition_size, output_size)
        self.laten2hidden = nn.Linear(latent_size, hidden_size)

    def forward(self, input, hidden):
        output = self.embedding(input).view(1, 1, -1)
        #print(hidden[1].shape)
        output, hidden = self.lstm1(output, hidden)
        output = self.out(output[0])
        return output, hidden

    def latent2Hidden(self, encoder_hidden, condition):
        condition = self.condition_emb(condition).view(1, 1, -1)
        hidden, temp_ = self.initHidden(condition)
        #print(self.laten2hidden(encoder_hidden))
        #print(condition)
        temp_ = torch.cat((self.laten2hidden(encoder_hidden), condition), dim=2)
        return (hidden, temp_) #return as tuple

    def initHidden(self, condition):
        return (torch.cat((torch.zeros(1, 1, self.hidden_size, device=device), condition), dim=2),
                torch.cat((torch.zeros(1, 1, self.hidden_size, device=device), condition), dim=2))

def train(input_tensor, target_tensor, label_tensor, encoder, decoder, encoder_optimizer, decoder_optimizer, encoder_sch, decoder_sch, criterion, cy_cnt):

    encoder_optimizer.zero_grad()
    decoder_optimizer.zero_grad()

    input_length = input_tensor.size(0)
    target_length = target_tensor.size(0)

    loss = 0

    #----------sequence to sequence part for encoder----------#
    mu, logvar = encoder(input_tensor, label_tensor[0])

    std = torch.exp(0.5 * logvar)
    eps = torch.randn_like(std)
    decoder_hidden = mu + eps * std
    decoder_hidden = decoder.latent2Hidden(decoder_hidden, label_tensor[1])
    decoder_input = torch.tensor(SOS_token, device=device)

    use_teacher_forcing = True if random.random() < teacher_forcing_ratio else False

    results = ""
    truth = ""
    #----------sequence to sequence part for decoder----------#
    if use_teacher_forcing:
        # Teacher forcing: Feed the target as the next input
        for di in range(target_length):
            decoder_output, decoder_hidden = decoder(
                decoder_input, decoder_hidden)
            loss += criterion(decoder_output, target_tensor[di].unsqueeze(0))
            decoder_input = target_tensor[di]  # Teacher forcing

    else:
        # Without teacher forcing: use its own predictions as the next input
        for di in range(target_length):
            decoder_output, decoder_hidden = decoder(
                decoder_input, decoder_hidden)
            topv, topi = decoder_output.topk(1)
            decoder_input = topi.squeeze().detach()  # detach from history as input
            number = decoder_input.item() - 1
            results += (chr(ord('`') + number))
            truth += (chr(ord('`') + target_tensor[di]-1))
            loss += criterion(decoder_output, target_tensor[di].unsqueeze(0))
            if decoder_input.item() == EOS_token:
                break
        results += " , " + truth

    CE = loss/target_length
    KLD = -0.5 * torch.sum(1 + logvar - mu.pow(2) - logvar.exp())

    if KL_annealing_mode == "Cyclical":
        if cy_cnt < KL_annealing_period :
            KLD_weight = cy_cnt/KL_annealing_period
            cy_cnt += 1
        elif cy_cnt<KL_annealing_period*1.5 :
            KLD_weight = 1
            cy_cnt += 1
        else:
            KLD_weight = 0
            cy_cnt = 0
    elif KL_annealing_mode == "Monotonic":
        if cy_cnt < (KL_annealing_period):
            KLD_weight = cy_cnt / (KL_annealing_period)
            cy_cnt += 1
        else:
            KLD_weight = 1
    elif KL_annealing_mode == "Step":
        if cy_cnt < (KL_annealing_period/5):
            KLD_weight = 0.0001
            cy_cnt += 1
        elif cy_cnt < (KL_annealing_period/5*2):
            KLD_weight = 2/5
            cy_cnt += 1
        elif cy_cnt < (KL_annealing_period/5*3):
            KLD_weight = 3/5
            cy_cnt += 1
        elif cy_cnt < (KL_annealing_period/5*4):
            KLD_weight = 4/5
            cy_cnt += 1
        elif cy_cnt < (KL_annealing_period):
            KLD_weight = 0.99
            cy_cnt += 1
        else:
            KLD_weight = 0.0001
            cy_cnt = 0
    else:
        KLD_weight = 0.0001

    loss_t = KLD*KLD_weight + CE
    loss_t.backward()

    encoder_optimizer.step()
    decoder_optimizer.step()

    encoder_sch.step()
    decoder_sch.step()

    return loss_t.item(), results, KLD, CE, cy_cnt


def eval(input, target, label_tensor, encoder, decoder, testing_times=20):


    encoder.eval()
    decoder.eval()
    Max_length=20

    pairs, label = dataloader("./train.txt")

    testing_pairs = []
    t_label_pairs = []

    for i in range(testing_times):
        rnd = random.randint(0, len(pairs) - 1)
        testing_pairs.append(pairs[rnd])
        t_label_pairs.append(label[rnd])

    with torch.no_grad():

        for iter in range(1, testing_times + 1):
            testing_pair = testing_pairs[iter - 1]
            input_tensor = string2num(testing_pair[0])
            input_tensor = torch.tensor(input_tensor, dtype=torch.long, device=device)
            target_tensor = string2num(testing_pair[1])
            target_tensor = np.append(target_tensor, EOS_token)  # use string2num
            # target_tensor = torch.tensor(target_tensor, dtype=torch.long, device=device)
            t_label_tensor = t_label_pairs[iter - 1]
            t_label_tensor = torch.tensor(t_label_tensor, dtype=torch.long, device=device)

            # ----------sequence to sequence part for encoder----------#
            mu, logvar = encoder(input_tensor, t_label_tensor[0])

            std = torch.exp(0.5 * logvar)
            eps = torch.randn_like(std)
            decoder_hidden = mu + eps * std
            decoder_hidden = decoder.latent2Hidden(decoder_hidden, t_label_tensor[1])
            decoder_input = torch.tensor(SOS_token, device=device)

            # ----------sequence to sequence part for decoder----------#
            results = ""
            for di in range(Max_length):
                decoder_output, decoder_hidden = decoder(
                    decoder_input, decoder_hidden)
                topv, topi = decoder_output.topk(1)
                decoder_input = topi.squeeze().detach()  # detach from history as input
                # decoder_outputs[di] = decoder_input
                number = decoder_input.item()-1
                #print("decoder_output:\n", chr(ord('`') + number))
                results+=(chr(ord('`') + number))
                #print("target \n", target_tensor[di])
                if decoder_input.item() == EOS_token:
                    break
            print(results, " , ", testing_pair[1])

def asMinutes(s):
    m = math.floor(s / 60)
    s -= m * 60
    return '%dm %ds' % (m, s)

def timeSince(since, percent):
    now = time.time()
    s = now - since
    es = s / (percent)
    rs = es - s
    return '%s (- %s)' % (asMinutes(s), asMinutes(rs))

def trainIters(encoder, decoder, n_iters, print_every=1000, plot_every=100, learning_rate=0.01):
    start = time.time()
    plot_losses = []
    print_loss_total = 0  # Reset every print_every
    plot_loss_total = 0  # Reset every plot_every
    print_KL_loss = 0
    print_CE_loss = 0

    pairs, label = dataloader("./source_code/data/train.txt")

    encoder_optimizer = optim.SGD(encoder.parameters(), lr=learning_rate)
    decoder_optimizer = optim.SGD(decoder.parameters(), lr=learning_rate)
    encoder_sch = optim.lr_scheduler.StepLR(encoder_optimizer, 200000, gamma=0.8)
    decoder_sch = optim.lr_scheduler.StepLR(decoder_optimizer, 200000, gamma=0.8)

    training_pairs=[]
    label_pairs=[]
    print("Data processing...")
    for i in range(n_iters):
        rnd = random.randint(0, len(pairs)-1)
        training_pairs.append(pairs[rnd])
        #lanel_ = torch.tensor(label[rnd], dtype=torch.long, device=device)
        label_pairs.append(label[rnd])
        input_, target_ = training_pairs[i]
        input_ = string2num(input_)
        #input_ = torch.tensor(input_, dtype=torch.long, device=device)
        target_ = string2num(target_)
        target_ = np.append(target_, EOS_token)
        #target_ = torch.tensor(target_, dtype=torch.long, device=device)
        training_pairs[i] = np.array([input_, target_])

    print("Start training...")

    # while len(training_pairs)<n_iters:
    #     rnd = random.randint(0, len(pairs) - 1)
    #     if (label[rnd]==[0,1]).all():
    #         training_pairs.append(pairs[rnd])
    #         label_pairs.append(label[rnd])
    result_print=""
    criterion = nn.CrossEntropyLoss()
    cy_cnt = 0
    for iter in range(1, n_iters + 1):
        encoder.train()
        decoder.train()
        training_pair = training_pairs[iter - 1]
        #input_tensor = training_pair[0]
        #target_tensor = training_pair[1]
        input_tensor = torch.tensor(training_pair[0], dtype=torch.long, device=device)
        target_tensor = torch.tensor(training_pair[1], dtype=torch.long, device=device)

        label_tensor = label_pairs[iter - 1]
        label_tensor = torch.tensor(label_tensor, dtype=torch.long, device=device)

        #print(target_tensor)
        #print(input_tensor)

        loss, result, KL_loss, CE_loss, cy_cnt = train(input_tensor, target_tensor, label_tensor, encoder,
                                                 decoder, encoder_optimizer, decoder_optimizer, encoder_sch, decoder_sch, criterion, cy_cnt)
        if result != "":
            result_print = result

        print_loss_total += loss
        plot_loss_total += loss
        print_KL_loss += KL_loss
        print_CE_loss += CE_loss

        if iter % print_every == 0:
            print_loss_avg = print_loss_total / print_every
            print('%s (%d %d%%) %.4f %.4f %.4f %s' % (timeSince(start, iter / n_iters),
                                                      iter, iter / n_iters * 100, print_loss_avg, print_KL_loss/print_every,
                                                      print_CE_loss/print_every,  result_print))
            if (iter % (print_every * 10) == 0):
                g_score, b_score = testing(encoder, decoder, False)
                print("Gaussian score:", g_score, "BLEU-4 score : ", b_score)
            if (iter % (print_every*10)==0) and iter>0 and (print_loss_avg <= 0.01):
                torch.save(encoder, "./model/encoder_" + str(iter) + "_" + str(print_loss_avg) + ".pkl")
                torch.save(decoder, "./model/decoder_" + str(iter) + "_" + str(print_loss_avg) + ".pkl")
            print_loss_total = 0
            print_KL_loss = 0
            print_CE_loss = 0

def dataloader(path):
    lines = open(path, encoding='utf-8').read().strip().split('\n')
    pairs = [[s for s in l.split(' ')] for l in lines]
    pairs = np.array(pairs)
    label = np.zeros((len(pairs)*16, 2), dtype=int)
    n_pairs = np.empty((len(pairs)*16, 2), dtype="<U20")
    for i in range(len(pairs)):
        # n_pairs[i * 10] = [pairs[i][0], pairs[i][0]]
        # n_pairs[i * 10 + 1] = [pairs[i][0], pairs[i][1]]
        # n_pairs[i * 10 + 2] = [pairs[i][0], pairs[i][2]]
        # n_pairs[i * 10 + 3] = [pairs[i][0], pairs[i][3]]
        # n_pairs[i * 10 + 4] = [pairs[i][1], pairs[i][1]]
        # n_pairs[i * 10 + 5] = [pairs[i][1], pairs[i][2]]
        # n_pairs[i * 10 + 6] = [pairs[i][1], pairs[i][3]]
        # n_pairs[i * 10 + 7] = [pairs[i][2], pairs[i][2]]
        # n_pairs[i * 10 + 8] = [pairs[i][2], pairs[i][3]]
        # n_pairs[i * 10 + 9] = [pairs[i][3], pairs[i][3]]
        # label[i * 10] = [0, 0]
        # label[i * 10 + 1] = [0, 1]
        # label[i * 10 + 2] = [0, 2]
        # label[i * 10 + 3] = [0, 3]
        # label[i * 10 + 4] = [1, 1]
        # label[i * 10 + 5] = [1, 2]
        # label[i * 10 + 6] = [1, 3]
        # label[i * 10 + 7] = [2, 2]
        # label[i * 10 + 8] = [2, 3]
        # label[i * 10 + 9] = [3, 3]
        cnt = 0
        for j in range(4):
            for k in range(4):
                n_pairs[i * 16+ cnt] = [pairs[i][j], pairs[i][k]]
                label[i * 16 + cnt] = [j, k]
                cnt+=1
    return n_pairs, label

def testing(encoder, decoder, print_):


    encoder.eval()
    decoder.eval()
    Max_length=20

    pairs, label = dataloader("./train.txt")

    testing_pairs = []
    t_label_pairs = []

    testing_times = 100
    for i in range(testing_times):
        rnd = random.randint(0, len(pairs) - 1)
        testing_pairs.append(pairs[rnd])
        t_label_pairs.append(label[rnd])

    with torch.no_grad():
        words=[]
        for iter in range(0, testing_times):
            eps = torch.zeros([1, 1, latent_size], dtype=torch.float)
            rnd_gaussian = torch.randn_like(eps)
            predicted=[]
            for i in range(4):
                label_tensor = torch.tensor(i, device=device)
                rnd_gaussian = torch.tensor(rnd_gaussian, device=device)
                decoder_hidden = decoder.latent2Hidden(rnd_gaussian, label_tensor)
                decoder_input = torch.tensor(SOS_token, device=device)

                # ----------sequence to sequence part for decoder----------#
                results = ""
                for di in range(Max_length):
                    decoder_output, decoder_hidden = decoder(
                        decoder_input, decoder_hidden)
                    topv, topi = decoder_output.topk(1)
                    decoder_input = topi.squeeze().detach()  # detach from history as input
                    # decoder_outputs[di] = decoder_input
                    number = decoder_input.item()-1
                    #print("decoder_output:\n", chr(ord('`') + number))
                    results+=(chr(ord('`') + number))
                    #print("target \n", target_tensor[di])
                    if decoder_input.item() == EOS_token:
                        break
                #print(results, " , ", results[:-1])
                predicted.append(results[:-1])
            words.append(predicted)
        if print_:
            print(words)
        score = Gaussian_score(words)
        if print_:
            print("Gaussian score : ", score)

        path = "./test.txt"
        lines = open(path, encoding='utf-8').read().strip().split('\n')
        pairs = [[s for s in l.split(' ')] for l in lines]
        label_pairs = [[0, 3], [0,2], [0,1], [0,1], [3,1], [0,2], [3,0], [2,0], [2,3], [2,1]]

        score_bleu = 0
        for iter in range(len(pairs)):
            # ----------sequence to sequence part for encoder----------#
            input_ = string2num(pairs[iter][0])
            input_tensor = torch.tensor(input_, device=device)
            label_tensor = torch.tensor(label_pairs[iter], device=device)
            mu, logvar = encoder(input_tensor, label_tensor[0])

            std = torch.exp(0.5 * logvar)
            eps = torch.randn_like(std)
            decoder_hidden = mu + eps * std
            decoder_hidden = decoder.latent2Hidden(decoder_hidden, label_tensor[1])
            decoder_input = torch.tensor(SOS_token, device=device)
            # ----------sequence to sequence part for decoder----------#
            results = ""
            for di in range(Max_length):
                decoder_output, decoder_hidden = decoder(
                    decoder_input, decoder_hidden)
                topv, topi = decoder_output.topk(1)
                decoder_input = topi.squeeze().detach()  # detach from history as input
                # decoder_outputs[di] = decoder_input
                number = decoder_input.item() - 1
                # print("decoder_output:\n", chr(ord('`') + number))
                results += (chr(ord('`') + number))
                # print("target \n", target_tensor[di])
                if decoder_input.item() == EOS_token:
                    break
            if(print_):
                print("input:", pairs[iter][0])
                print("target:", pairs[iter][1])
                print("prediction:", results[:-1], "\n")

            score_bleu += compute_bleu(results[:-1], pairs[iter][1])
        if(print_):
            print("Average BLEU-4 score : ", score_bleu/len(pairs))
        return score, score_bleu/len(pairs)

train_=True

if train_:
    encoder1 = EncoderRNN(vocab_size, latent_size, hidden_size, condition_embedded_size).to(device)
    decoder1 = DecoderRNN(vocab_size, latent_size, hidden_size, vocab_size, condition_embedded_size).to(device)
    trainIters(encoder1, decoder1, 3000000, print_every=5000, learning_rate=LR)
else:
    encoder1 = torch.load("./model/encoder_2820000_0.005773096800642088.pkl")
    decoder1 = torch.load("./model/decoder_2820000_0.005773096800642088.pkl")
    testing(encoder1, decoder1, True)
#eval(0, 0, 0, encoder1, decoder1, 20)

